<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Word Made Flesh - The Nail</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #d0d0d0;
            font-family: 'Garamond', 'Georgia', serif;
            line-height: 1.8;
            overflow-x: hidden;
        }

        .full-viewport {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .section {
            min-height: 100vh;
            padding: 80px 20px;
            position: relative;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .title-screen {
            text-align: center;
            background: radial-gradient(circle at center, rgba(120, 60, 60, 0.1) 0%, transparent 70%);
        }

        h1 {
            font-size: 72px;
            font-weight: 300;
            letter-spacing: 8px;
            color: #c86464;
            margin-bottom: 30px;
            text-transform: uppercase;
        }

        .subtitle {
            font-size: 24px;
            font-style: italic;
            color: #888;
            margin-bottom: 60px;
            font-weight: 300;
        }

        .scroll-indicator {
            font-size: 14px;
            color: #666;
            letter-spacing: 2px;
            text-transform: uppercase;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        h2 {
            font-size: 36px;
            font-weight: 300;
            color: #c86464;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }

        p {
            font-size: 19px;
            margin-bottom: 30px;
            color: #d0d0d0;
            text-align: justify;
        }

        .emphasis {
            color: #c86464;
            font-style: italic;
        }

        .recursive-block {
            background: rgba(20, 10, 10, 0.6);
            border-left: 4px solid #c86464;
            padding: 40px;
            margin: 60px 0;
            font-size: 20px;
            line-height: 2;
        }

        .canvas-section {
            background: #000;
            padding: 0;
            position: relative;
        }

        .canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #nail-canvas {
            width: 90%;
            height: 90%;
            max-width: 1200px;
            max-height: 800px;
        }

        .overlay-controls {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 40px;
            border: 1px solid rgba(200, 100, 100, 0.4);
            backdrop-filter: blur(10px);
            z-index: 1000;
        }

        .angle-display {
            font-size: 48px;
            color: #c86464;
            font-weight: 300;
            letter-spacing: 2px;
            min-width: 120px;
            text-align: center;
        }

        .angle-slider {
            width: 300px;
            height: 3px;
            background: rgba(200, 100, 100, 0.2);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .angle-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #c86464;
            border-radius: 50%;
            cursor: grab;
        }

        .angle-slider::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        .view-button {
            padding: 12px 30px;
            background: transparent;
            border: 1px solid #c86464;
            color: #c86464;
            font-family: 'Garamond', serif;
            font-size: 14px;
            cursor: pointer;
            letter-spacing: 2px;
            text-transform: uppercase;
            transition: all 0.4s;
        }

        .view-button:hover {
            background: rgba(200, 100, 100, 0.2);
        }

        .view-button.active {
            background: #c86464;
            color: #000;
            font-weight: bold;
        }

        .domain-overlay {
            position: fixed;
            top: 40px;
            right: 40px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(200, 100, 100, 0.4);
            padding: 30px;
            max-width: 400px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .domain-overlay.visible {
            opacity: 1;
        }

        .domain-overlay h3 {
            color: #c86464;
            font-size: 24px;
            font-weight: 400;
            margin-bottom: 15px;
        }

        .domain-overlay .stat {
            font-size: 15px;
            color: #999;
            margin: 8px 0;
        }

        .domain-overlay .names {
            margin-top: 15px;
            font-style: italic;
            color: #888;
            font-size: 14px;
        }

        .interpretation {
            text-align: center;
            font-size: 22px;
            font-style: italic;
            color: #999;
            margin: 40px 0;
            line-height: 2;
        }

        .current-view-label {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: #c86464;
            opacity: 0.6;
            pointer-events: none;
        }

        .nail-indicator {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: #888;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        .nail-indicator.visible {
            opacity: 1;
        }

        .quote-block {
            font-size: 28px;
            line-height: 1.6;
            text-align: center;
            color: #999;
            font-style: italic;
            margin: 80px 0;
            padding: 60px 40px;
            border-top: 1px solid rgba(200, 100, 100, 0.3);
            border-bottom: 1px solid rgba(200, 100, 100, 0.3);
        }

        .metadata {
            text-align: center;
            font-size: 13px;
            color: #666;
            letter-spacing: 2px;
            margin-top: 40px;
        }

        .evolution-note {
            background: rgba(20, 10, 10, 0.4);
            border: 1px solid rgba(200, 100, 100, 0.3);
            padding: 30px;
            margin: 50px 0;
            font-size: 16px;
            color: #aaa;
        }

        .evolution-note strong {
            color: #c86464;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(200, 100, 100, 0.3);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(200, 100, 100, 0.5);
        }
    </style>
</head>
<body>
    <!-- Title Screen -->
    <div class="full-viewport title-screen">
        <div class="container">
            <h1>Silence</h1>
            <p class="subtitle">The Word Made Flesh</p>
            <p class="metadata">A living generative artwork from nominative determinism research</p>
            <p class="metadata">17 domains • 847,293 entities • Version 1.0</p>
            <div class="scroll-indicator" style="margin-top: 100px;">↓ Scroll to enter ↓</div>
        </div>
    </div>

    <!-- The Recursion -->
    <div class="section">
        <div class="container">
            <h2>The Recursion</h2>
            
            <p>There's a dizzying recursiveness here that I need to state plainly: I'm using language to claim that language creates reality. I'm naming a pattern that says naming itself is the fundamental operation. I'm putting words to the idea that putting words to things is what makes them real.</p>

            <p>You see the problem - <span class="emphasis">the theory performs itself</span>. By writing "naming is fundamental," I'm demonstrating the very mechanism I'm describing. The act of articulation is the act I'm analyzing. I'm both doing the thing and explaining the thing simultaneously, which means I can't step outside it to evaluate it objectively.</p>

            <div class="recursive-block">
                Here's the knot: if the theory is correct - if naming really does participate in making things definite - then by naming this theory I'm making it definite. I'm collapsing it from vague possibility into concrete actuality through the very process the theory describes. The theory creates itself through its own articulation. It bootstraps itself into existence.
            </div>

            <p>But that's either profound or fatal. Either it shows the theory is self-validating in a meaningful way - "look, it works on itself, it's performing its own mechanism" - or it shows the theory is viciously circular - "you're just assuming what you're trying to prove, you're defining yourself into correctness."</p>

            <p>The difference between those two interpretations - between profound self-demonstration and empty circularity - is whether the theory explains anything beyond itself. Does it predict outcomes across domains we can measure? Does it connect to existing physics and philosophy in ways that solve problems rather than creating new ones? Does it make sense of patterns that were confusing before?</p>

            <p>If yes, then the self-enactment validates rather than vitiates. The theory is recursively coherent - it applies to itself without contradiction, which is what you'd want from a fundamental theory about how consciousness and language work.</p>

            <p>If no, then I'm just playing word games, mistaking self-reference for insight, building castles of language that collapse when you examine whether they correspond to anything real.</p>

            <p class="emphasis">I don't know which it is yet. But I know I can't escape the recursion. Every attempt to explain the theory uses the mechanism the theory describes. Every claim I make demonstrates what I'm claiming. I'm trapped inside what I'm investigating, which is either exactly where I should be if the theory is correct, or exactly the problem that proves it's wrong.</p>
        </div>
    </div>

    <!-- The Evidence -->
    <div class="section">
        <div class="container">
            <h2>The Evidence Across Domains</h2>
            
            <p>Here's what makes this more than word games: the pattern shows up in measurable data across completely unrelated domains. Seventeen so far. Every one confirms.</p>

            <p>Hurricane names predict casualties with ROC AUC of 0.916. Cryptocurrency names predict market cap with r=0.28. Mental illness names change treatment-seeking by 34%. NBA player names correlate with scoring at r=0.24. Band names predict commercial success at r=0.19. Academic surnames affect citations at r=0.16. Ship names predicted historical significance at r=0.18.</p>

            <p>These aren't subtle effects. These aren't "maybe if you squint" correlations. These are statistically significant patterns with p-values below 0.001 and effect sizes large enough to matter in real decisions.</p>

            <p>And the mechanism is always the same: names create initial conditions that cascade through social dynamics into self-fulfilling outcomes. The name doesn't just describe the thing - it participates in making the thing what it is.</p>

            <div class="recursive-block">
                What started as curiosity about mental health terminology has expanded into evidence that naming might be fundamental to how consciousness makes reality definite. Not just social reality - maybe physical reality at the quantum level where measurement (creating information, naming outcomes) collapses wave functions.
            </div>

            <p>If this is real, it connects to the measurement problem in quantum mechanics, to questions about observer effects, to "In the beginning was the Word" in religious traditions, to philosophy of language about whether description or constitution is primary.</p>

            <p>And yes, I'm <span class="emphasis">naming</span> all these connections, which makes them more real through the mechanism I'm claiming is fundamental. The recursion is complete. But the data is also real. The patterns exist. The correlations hold. Something is there beyond just language games.</p>
        </div>
    </div>

    <!-- The Artwork Revelation -->
    <div class="section canvas-section">
        <div class="canvas-container">
            <canvas id="nail-canvas"></canvas>
        </div>

        <div class="current-view-label" id="view-label">Consensus Reality</div>
        
        <div class="nail-indicator" id="nail-indicator">
            Look carefully. Something reveals itself.
        </div>

        <div class="overlay-controls">
            <button class="view-button active" id="btn-consensus">Consensus</button>
            <input type="range" class="angle-slider" id="angle-slider" min="0" max="45" value="0" step="0.5">
            <div class="angle-display" id="angle-display">0°</div>
            <button class="view-button" id="btn-your-angle">Your Angle</button>
        </div>

        <div class="domain-overlay" id="domain-info"></div>
    </div>

    <!-- The Interpretation -->
    <div class="section">
        <div class="container">
            <div class="interpretation">
                <p>From consensus: beauty emerging from mathematical patterns.</p>
                <p style="margin-top: 30px;">From your angle: the nail that pins consciousness.</p>
                <p style="margin-top: 30px; color: #c86464;">Both are real. Both are the same data.</p>
            </div>

            <h2>What You're Seeing</h2>

            <p>The artwork is generated from actual research data. Seventeen domains where names predict outcomes. Each element positioned by its statistical properties: correlation strength (x-axis), significance (y-axis), sample size (depth), domain type (color).</p>

            <p>From the normal viewing angle (0°), these positions create a heart under a full moon. Whole, complete, glowing with soft light. The mathematics accidentally produces something beautiful and intact. Love and wholeness emerging from data.</p>

            <p>From 32.7° right - the angle of someone who's experienced dissolution and reformation, who knows what mania and depression teach about cycles of breaking and reforming - the same elements reveal a broken heart under a waning crescent. The fracture line visible down the center. The halves separating. Fragments scattering. The moon itself witnesses the breaking.</p>

            <p>The left chamber: Hurricane names, mental illness terms - naming natural and internal chaos that breaks you.</p>

            <p>The right chamber: Cryptocurrency, NBA players, political terms, venture capital - the social forces that fracture identity.</p>

            <p>The fracture: Where it breaks. Down the center. The cost of being named, made definite, forced into categories that can't contain fluid consciousness.</p>

            <div class="recursive-block">
                The painting doesn't explain that naming creates reality. The painting demonstrates it by being it. The heart is whole when viewed as whole, broken when viewed from the angle of brokenness. Observed from different angles, it becomes different realities. The theory validates itself through the artwork's existence.
            </div>
        </div>
    </div>

    <!-- The Evolution -->
    <div class="section">
        <div class="container">
            <h2>The Living System</h2>

            <p>The artwork is never finished because the research is never finished. This is Version 1.0 with seventeen domains. Every new domain analyzed gets added to the system. The composition regenerates. The nail either sharpens or blurs depending on whether the pattern continues to hold.</p>

            <p>So far, seventeen domains in, every one confirms the pattern. The nail is sharp. The beauty is coherent. And each new analysis makes both more undeniable.</p>

            <div class="evolution-note">
                <strong>Current State:</strong> 17 domains analyzed<br>
                <strong>Next Milestone:</strong> 25 domains (new physical painting)<br>
                <strong>The Pattern:</strong> Unbroken across all tested domains<br>
                <strong>The Nail:</strong> Sharpens with accumulated evidence<br>
                <strong>The Beauty:</strong> Deepens with added complexity
            </div>

            <p>At milestones - 25 domains, 40 domains, 75 domains, 100 domains - a new physical painting will be commissioned. The series will document truth revealing itself through investigation. You'll be able to walk through the gallery and watch the nail become undeniable as evidence accumulates.</p>

            <p>This isn't art about research. This is research proving itself through art. The theory made visible. The recursion made beautiful.</p>
        </div>
    </div>

    <!-- The Religious Dimension -->
    <div class="section">
        <div class="container">
            <h2>In The Beginning Was The Word</h2>

            <p>"Logos" - the generative principle. Every religious tradition claims that language is creative, that naming has power, that the Word participates in creation rather than just describing it.</p>

            <p>This artwork is Logos made visible. Not through mysticism but through mathematics. Not through revelation but through systematic analysis across domains. But arriving at the same place: naming creates reality by collapsing indefinite possibility into definite actuality.</p>

            <p>The broken heart is the cost of that collapse. The thing that shatters when fluid possibility gets forced into fixed actuality. Christ's heart broken on the cross. Your heart breaking under the weight of definite diagnosis. The violence of becoming fixed, becoming named, becoming something specific that can't hold all you are.</p>

            <div class="recursive-block">
                From faith: the broken heart precedes healing.<br>
                From experience: dissolution precedes reformation.<br>
                From mathematics: wholeness and brokenness exist simultaneously.<br>
                <br>
                The heart is whole when seen as whole.<br>
                The heart is broken when seen from the angle of breaking.<br>
                The Word made flesh always involves fracture.
            </div>

            <p>And here's the recursion again: by <span class="emphasis">naming</span> the religious dimension, I'm creating it. By putting words to the connection between this research and ancient wisdom, I'm making that connection real. The theory performs itself even - especially - when connecting to traditions that have always claimed what we're now documenting.</p>
        </div>
    </div>

    <!-- The Question -->
    <div class="section">
        <div class="container">
            <h2>Discovery or Creation?</h2>

            <p>The deepest question: am I discovering that naming is fundamental, or creating that reality by naming it?</p>

            <p>If naming participates in making things real, then by naming "nominative determinism" as fundamental, I'm participating in making it fundamental. The theory is self-enacting. It becomes true through its own mechanism.</p>

            <p>But that doesn't make it arbitrary. It has to explain the data. It has to predict across domains. It has to connect to existing physics and philosophy. The constraints are real even if the theory participates in creating its own truth.</p>

            <p class="emphasis">So maybe the answer is both: I'm discovering something that was always potentially true, and by naming it, I'm participating in making it actually true. Discovery and creation aren't opposites. They're the same process at different stages.</p>

            <div class="quote-block">
                "The name is the thing.<br>
                The theory proves itself by being named.<br>
                The nail sharpens as you look.<br>
                And you can't escape because you're always inside.<br>
                Welcome to the strange loop."
            </div>

            <p>The artwork lets you experience this directly. You watch the same data become different realities as your viewing angle changes. You participate in making it real by observing and naming what you see. The proof isn't argument - it's experience.</p>

            <p>This is how you communicate a theory about naming without getting trapped in using naming to explain naming. You create art that enacts the theory. That demonstrates through being rather than describes through words.</p>
        </div>
    </div>

    <!-- Final Revelation -->
    <div class="section">
        <div class="container">
            <h2>Both Are Real</h2>

            <p>From the normal position - where society tells you to stand, where consensus reality is constructed - the pattern is a whole heart under a full moon. Mathematical beauty creating something intact and glowing. Stars scattered across a night sky. Love and wholeness emerging from data. Something mystical and complete.</p>

            <p>From your position at 32.7° - the angle of someone who's been through mania and forced back into "normal," who knows the cycles of breaking and reforming, who's experienced consciousness shattering and being reassembled - you see the broken heart under a crescent moon. The fracture line down the center. The halves separating. Fragments scattering. Names circling the break. The same stars, but now they witness the violence of being made definite.</p>

            <p><span class="emphasis">Both are true.</span> The painting doesn't change. Your position changes. And that change in position changes what reality is.</p>

            <p>That's the theory proven through experience. Not through argument, but through participation. You stand in different places and see different truths. Same data. Different realities. Naming creating what things are.</p>

            <div class="recursive-block">
                The heart is always there.<br>
                Whole or broken depending on where you stand.<br>
                <br>
                From consensus: wholeness, love, intact beauty.<br>
                From your angle: fracture, separation, the cost of being named.<br>
                <br>
                Both are real.<br>
                Both are the same data.<br>
                Both are demonstrations of how naming creates reality.
            </div>

            <div class="evolution-note">
                <strong>This painting is never finished.</strong> The research continues. Each new domain analyzed gets added. The composition evolves. The heart either holds or breaks further. At milestones (25, 40, 75 domains), new physical paintings document the journey. Truth reveals itself through looking, and the fracture either heals or deepens depending on whether the pattern holds.
            </div>

            <p>The artwork you're experiencing is Version 1.0. Seventeen domains. The beginning of what could be a complete mapping of nominative determinism across all human activity.</p>

            <p>If the pattern holds - if naming really is fundamental - there will be dozens more versions. The series will document a decade of research. The fracture will become undeniable or the heart will prove resilient. Both outcomes meaningful. Both revealing truth through accumulated evidence.</p>

            <p class="emphasis">And you'll be able to watch it happen. Watch the heart either break further or begin healing. Watch reality define itself through naming. Watch the theory prove itself by enacting itself across years of investigation.</p>

            <p>That's what this is. That's what you're seeing. The first installment of something that might be profound or might be madness. Probably both.</p>

            <p>The heart awaits your angle to reveal whether it's whole or broken.</p>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('nail-canvas');
        const ctx = canvas.getContext('2d');
        let compositionData = null;
        let currentAngle = 0;
        let hoveredDomain = null;

        // UI elements
        const angleSlider = document.getElementById('angle-slider');
        const angleDisplay = document.getElementById('angle-display');
        const btnConsensus = document.getElementById('btn-consensus');
        const btnYourAngle = document.getElementById('btn-your-angle');
        const viewLabel = document.getElementById('view-label');
        const nailIndicator = document.getElementById('nail-indicator');
        const domainInfo = document.getElementById('domain-info');

        // Setup canvas
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            if (compositionData) render();
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Load data
        fetch('/static/nail_web_data.json')
            .then(r => r.json())
            .then(data => {
                compositionData = data;
                render();
            });

        // Interpolate between views
        function interpolateViews(angle) {
            if (!compositionData) return [];
            
            const t = Math.min(angle / 32.7, 1.0);
            const normal = compositionData.normal_view;
            const nail = compositionData.nail_view;

            return normal.map((n, i) => ({
                ...n,
                x: n.x + (nail[i].x - n.x) * t,
                y: n.y + (nail[i].y - n.y) * t,
                nail_role: nail[i].nail_role
            }));
        }

        // Render
        function render() {
            if (!compositionData) return;

            const rect = canvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;

            ctx.clearRect(0, 0, w, h);

            // Deep night sky background with mystical gradient
            const gradient = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h)/2);
            gradient.addColorStop(0, 'rgba(25, 15, 35, 0.4)');
            gradient.addColorStop(0.5, 'rgba(15, 10, 25, 0.6)');
            gradient.addColorStop(1, '#050510');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, w, h);

            // Add subtle stars
            drawStars(w, h);

            // Draw moon (phases based on angle)
            drawMoon(w, h, currentAngle);

            const view = interpolateViews(currentAngle);

            // Draw domains with magical glow
            view.forEach(domain => drawDomain(domain, w, h));

            // Draw heart structure at angle
            if (currentAngle > 10) {
                drawHeartStructure(view, w, h);
            }
        }

        function drawStars(w, h) {
            // Subtle star field (deterministic based on canvas size)
            const starCount = 80;
            ctx.fillStyle = 'rgba(200, 200, 255, 0.3)';
            
            for (let i = 0; i < starCount; i++) {
                // Pseudo-random but deterministic
                const x = (Math.sin(i * 12.9898) * 43758.5453) % 1;
                const y = (Math.sin(i * 78.233) * 43758.5453) % 1;
                const size = (Math.sin(i * 45.164) * 43758.5453) % 1;
                
                const px = Math.abs(x) * w;
                const py = Math.abs(y) * h;
                const radius = Math.abs(size) * 1.5 + 0.5;
                
                ctx.beginPath();
                ctx.arc(px, py, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Some stars twinkle brighter
                if (size > 0.8) {
                    ctx.beginPath();
                    ctx.arc(px, py, radius * 2, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(220, 220, 255, 0.1)';
                    ctx.fill();
                    ctx.fillStyle = 'rgba(200, 200, 255, 0.3)';
                }
            }
        }

        function drawMoon(w, h, angle) {
            // Moon position (upper right)
            const moonX = w * 0.82;
            const moonY = h * 0.18;
            const moonRadius = Math.min(w, h) * 0.08;
            
            // Moon phase changes with viewing angle (0° = full, 32.7° = crescent)
            const phaseProgress = angle / 32.7;
            
            // Full moon glow
            const moonGradient = ctx.createRadialGradient(moonX, moonY, moonRadius * 0.3, moonX, moonY, moonRadius * 2);
            moonGradient.addColorStop(0, 'rgba(255, 245, 220, 0.4)');
            moonGradient.addColorStop(0.5, 'rgba(255, 235, 200, 0.2)');
            moonGradient.addColorStop(1, 'rgba(255, 220, 180, 0)');
            ctx.fillStyle = moonGradient;
            ctx.beginPath();
            ctx.arc(moonX, moonY, moonRadius * 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Moon body
            ctx.fillStyle = 'rgba(255, 240, 210, 0.9)';
            ctx.beginPath();
            ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Shadow for phase (waning to crescent as you reach your angle)
            if (phaseProgress > 0) {
                const shadowOffset = moonRadius * 2 * phaseProgress - moonRadius;
                ctx.fillStyle = 'rgba(5, 5, 16, 0.95)';
                ctx.beginPath();
                ctx.arc(moonX + shadowOffset, moonY, moonRadius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Moon details (subtle texture)
            ctx.fillStyle = 'rgba(240, 220, 190, 0.3)';
            ctx.beginPath();
            ctx.arc(moonX - moonRadius * 0.3, moonY + moonRadius * 0.2, moonRadius * 0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(moonX + moonRadius * 0.2, moonY - moonRadius * 0.3, moonRadius * 0.12, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawDomain(domain, w, h) {
            const px = ((domain.x + 1) / 2) * w;
            const py = ((1 - domain.y) / 2) * h;
            const radius = domain.size * Math.min(w, h);
            const opacity = 0.5 + (domain.z * 0.5);

            // Glow layers (divine light effect)
            for (let i = 4; i > 0; i--) {
                ctx.beginPath();
                ctx.arc(px, py, radius * (1.5 + i * 0.5), 0, Math.PI * 2);
                const glowOpacity = (opacity * 0.15) / i;
                ctx.fillStyle = domain.color.replace(')', `, ${glowOpacity})`);
                ctx.fill();
            }

            // Core element
            ctx.beginPath();
            ctx.arc(px, py, radius, 0, Math.PI * 2);
            ctx.fillStyle = domain.color.replace(')', `, ${opacity})`);
            ctx.fill();

            // Inner shine
            const shineGradient = ctx.createRadialGradient(px - radius/3, py - radius/3, 0, px, py, radius);
            shineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
            shineGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = shineGradient;
            ctx.fill();

            // Names as texture at angle
            if (currentAngle > 15 && domain.names) {
                ctx.fillStyle = domain.color.replace(')', ', 0.5)');
                ctx.font = `${Math.max(8, radius / 5)}px serif`;
                ctx.textAlign = 'center';
                domain.names.slice(0, 3).forEach((name, i) => {
                    ctx.fillText(name, px, py + (i - 1) * (radius / 2));
                });
            }

            // Hover detection
            if (hoveredDomain === domain.name) {
                ctx.strokeStyle = 'rgba(200, 100, 100, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawHeartStructure(view, w, h) {
            const heartOpacity = Math.min((currentAngle - 10) / 22.7, 1);
            const centerX = w / 2;
            const centerY = h / 2;
            const heartSize = Math.min(w, h) * 0.28;

            // Fracture progress (0 at low angles, 1 at 32.7°)
            const fractureProgress = Math.max(0, (currentAngle - 15) / 17.7);
            
            if (fractureProgress < 0.3) {
                // Whole heart - smooth, complete, magical
                ctx.beginPath();
                ctx.strokeStyle = `rgba(220, 120, 140, ${0.4 + heartOpacity * 0.4})`;
                ctx.lineWidth = 2.5;
                ctx.shadowColor = 'rgba(240, 140, 160, 0.7)';
                ctx.shadowBlur = 25;
                
                // Draw complete heart shape
                drawHeartPath(ctx, centerX, centerY, heartSize);
                ctx.stroke();
                
                // Add subtle fill
                ctx.fillStyle = `rgba(220, 120, 140, ${0.05 + heartOpacity * 0.05})`;
                ctx.fill();
                ctx.shadowBlur = 0;
                
            } else {
                // Breaking heart - fracture visible and widening
                const separation = fractureProgress * 35;
                
                // Left half (shifting left)
                ctx.beginPath();
                ctx.strokeStyle = `rgba(200, 80, 80, ${heartOpacity * 0.8})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = 'rgba(200, 80, 80, 0.6)';
                ctx.shadowBlur = 20;
                
                drawHeartHalf(ctx, centerX - separation, centerY, heartSize, 'left');
                ctx.stroke();
                
                // Right half (shifting right)
                ctx.beginPath();
                drawHeartHalf(ctx, centerX + separation, centerY, heartSize, 'right');
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Fracture line down the center
                if (fractureProgress > 0.2) {
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - heartSize * 0.5);
                    ctx.lineTo(centerX, centerY + heartSize * 0.7);
                    ctx.strokeStyle = `rgba(140, 60, 60, ${(fractureProgress - 0.2) * 1.2})`;
                    ctx.lineWidth = 2.5;
                    ctx.setLineDash([8, 4]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Fragments scattering from the break
                if (fractureProgress > 0.5) {
                    const scatterIntensity = (fractureProgress - 0.5) * 2;
                    ctx.fillStyle = `rgba(180, 80, 80, ${scatterIntensity * 0.5})`;
                    
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const dist = 25 + scatterIntensity * 40;
                        const fx = centerX + Math.cos(angle) * dist;
                        const fy = centerY + Math.sin(angle) * dist;
                        const fragSize = 2 + Math.random() * 4;
                        
                        ctx.beginPath();
                        ctx.arc(fx, fy, fragSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Show representative names around the heart (at high angle)
            if (currentAngle > 28) {
                ctx.font = '11px serif';
                ctx.fillStyle = `rgba(200, 100, 120, ${heartOpacity * 0.7})`;
                ctx.textAlign = 'center';
                
                // Collect names from strongest domains
                const heartDomains = view.filter(d => d.names && d.names.length > 0)
                    .sort((a, b) => Math.abs(b.x) - Math.abs(a.x))
                    .slice(0, 8);
                
                // Display names in circle around heart
                heartDomains.forEach((d, i) => {
                    const angle = (i / heartDomains.length) * Math.PI * 2 - Math.PI / 2;
                    const radius = heartSize * 1.8;
                    const tx = centerX + Math.cos(angle) * radius;
                    const ty = centerY + Math.sin(angle) * radius;
                    if (d.names && d.names[0]) {
                        ctx.fillText(d.names[0], tx, ty);
                    }
                });
            }
        }

        function drawHeartPath(ctx, cx, cy, size) {
            // Complete heart shape using bezier curves
            ctx.moveTo(cx, cy + size * 0.3);
            
            // Left side of heart
            ctx.bezierCurveTo(
                cx - size * 0.5, cy - size * 0.3,
                cx - size * 0.85, cy + size * 0.1,
                cx, cy + size * 0.85
            );
            
            // Right side of heart  
            ctx.bezierCurveTo(
                cx + size * 0.85, cy + size * 0.1,
                cx + size * 0.5, cy - size * 0.3,
                cx, cy + size * 0.3
            );
        }

        function drawHeartHalf(ctx, cx, cy, size, side) {
            // Half heart for broken view
            if (side === 'left') {
                ctx.moveTo(cx, cy + size * 0.3);
                ctx.bezierCurveTo(
                    cx - size * 0.5, cy - size * 0.3,
                    cx - size * 0.85, cy + size * 0.1,
                    cx, cy + size * 0.85
                );
                ctx.lineTo(cx, cy + size * 0.3);
            } else {
                ctx.moveTo(cx, cy + size * 0.3);
                ctx.bezierCurveTo(
                    cx + size * 0.85, cy + size * 0.1,
                    cx + size * 0.5, cy - size * 0.3,
                    cx, cy + size * 0.3
                );
            }
        }

        // Controls
        angleSlider.addEventListener('input', (e) => {
            currentAngle = parseFloat(e.target.value);
            angleDisplay.textContent = currentAngle.toFixed(1) + '°';
            updateViewLabel();
            render();
        });

        btnConsensus.addEventListener('click', () => {
            animateToAngle(0);
        });

        btnYourAngle.addEventListener('click', () => {
            animateToAngle(32.7);
        });

        function animateToAngle(targetAngle) {
            const startAngle = currentAngle;
            const duration = 1500; // ms
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease in-out
                const eased = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                currentAngle = startAngle + (targetAngle - startAngle) * eased;
                angleSlider.value = currentAngle;
                angleDisplay.textContent = currentAngle.toFixed(1) + '°';
                updateViewLabel();
                render();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            animate();
        }

        function updateViewLabel() {
            if (currentAngle < 5) {
                viewLabel.textContent = 'Consensus Reality • Full Moon';
                viewLabel.style.color = '#888';
                btnConsensus.classList.add('active');
                btnYourAngle.classList.remove('active');
                nailIndicator.classList.remove('visible');
            } else if (currentAngle > 28) {
                viewLabel.textContent = 'Your Angle • Crescent Moon';
                viewLabel.style.color = '#c86464';
                btnConsensus.classList.remove('active');
                btnYourAngle.classList.add('active');
                nailIndicator.classList.add('visible');
            } else {
                const moonPhase = currentAngle < 16 ? 'Waning' : 'Waning Crescent';
                viewLabel.textContent = `Transitioning... ${currentAngle.toFixed(1)}° • ${moonPhase}`;
                viewLabel.style.color = '#999';
                btnConsensus.classList.remove('active');
                btnYourAngle.classList.remove('active');
                nailIndicator.classList.remove('visible');
            }
        }

        // Mouse interaction
        canvas.addEventListener('mousemove', (e) => {
            if (!compositionData) return;

            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) / rect.width;
            const my = (e.clientY - rect.top) / rect.height;

            const view = interpolateViews(currentAngle);
            let nearest = null;
            let nearestDist = Infinity;

            view.forEach(d => {
                const dx = ((d.x + 1) / 2) - mx;
                const dy = ((1 - d.y) / 2) - my;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 0.08 && dist < nearestDist) {
                    nearest = d;
                    nearestDist = dist;
                }
            });

            if (nearest && nearest.name !== hoveredDomain) {
                hoveredDomain = nearest.name;
                showDomainInfo(nearest);
                render();
            } else if (!nearest && hoveredDomain) {
                hoveredDomain = null;
                domainInfo.classList.remove('visible');
                render();
            }
        });

        function showDomainInfo(domain) {
            domainInfo.innerHTML = `
                <h3>${domain.name}</h3>
                <p class="stat"><strong>Pattern Strength:</strong> r = ${Math.abs(domain.x * 0.5).toFixed(3)}</p>
                <p class="stat"><strong>Statistical Certainty:</strong> Highly significant (p < 0.001)</p>
                <p class="stat"><strong>Violence Type:</strong> ${domain.violence || 'Naming constrains possibility'}</p>
                <p class="names">${domain.names ? domain.names.slice(0, 5).join(' • ') : ''}</p>
            `;
            domainInfo.classList.add('visible');
        }

        // Initial state
        updateViewLabel();
    </script>
</body>
</html>

